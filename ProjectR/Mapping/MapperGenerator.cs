using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Threading;

namespace ProjectR
{
    [Generator]
    public class MapperGenerator : IIncrementalGenerator
    {
        public MapperGenerator()
        {
            //#if DEBUG
            //            if (!Debugger.IsAttached)
            //            {
            //                Debugger.Launch();
            //            }
            //#endif
        }

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var compilationAndClasses = context.CompilationProvider
                .Select((compilation, ct) =>
                {
                    var explicitMappers = new Dictionary<string, ClassDeclarationSyntax>();
                    var dtosWithAttribute = new List<(INamedTypeSymbol DtoSymbol, INamedTypeSymbol EntitySymbol)>();

                    var mapperBaseSymbol = compilation.GetTypeByMetadataName("ProjectR.Mapper`2");
                    var dtoAttributeSymbol = compilation.GetTypeByMetadataName("ProjectR.Attributes.DtoAttribute`1");

                    // First pass: Find all explicit mappers and DTOs with attributes
                    foreach (var tree in compilation.SyntaxTrees)
                    {
                        var semanticModel = compilation.GetSemanticModel(tree);
                        foreach (var classNode in tree.GetRoot(ct).DescendantNodes().OfType<ClassDeclarationSyntax>())
                        {
                            if (semanticModel.GetDeclaredSymbol(classNode, ct) is not INamedTypeSymbol classSymbol) continue;

                            // Check for explicit mapper
                            if (mapperBaseSymbol != null && classSymbol.BaseType is { IsGenericType: true } &&
                                SymbolEqualityComparer.Default.Equals(classSymbol.BaseType.OriginalDefinition, mapperBaseSymbol))
                            {
                                explicitMappers[classSymbol.Name] = classNode;
                            }

                            // Check for DTO attribute
                            var attribute = classSymbol.GetAttributes().FirstOrDefault(ad =>
                                dtoAttributeSymbol != null && ad.AttributeClass?.OriginalDefinition.Equals(dtoAttributeSymbol, SymbolEqualityComparer.Default) == true);

                            if (attribute?.AttributeClass is { TypeArguments.Length: 1 } &&
                                attribute.AttributeClass.TypeArguments[0] is INamedTypeSymbol entitySymbol)
                            {
                                dtosWithAttribute.Add((classSymbol, entitySymbol));
                            }
                        }
                    }

                    return (compilation, explicitMappers, dtosWithAttribute);
                });


            context.RegisterSourceOutput(compilationAndClasses,
                static (spc, source) => Execute(source.compilation, source.explicitMappers, source.dtosWithAttribute, spc));
        }


        private static void Execute(Compilation compilation,
                                    Dictionary<string, ClassDeclarationSyntax> explicitMappers,
                                    List<(INamedTypeSymbol DtoSymbol, INamedTypeSymbol EntitySymbol)> dtosWithAttribute,
                                    SourceProductionContext context)
        {
            var allMapperClassesToImplement = new List<ClassDeclarationSyntax>(explicitMappers.Values);
            var placeholderSyntaxTrees = new List<SyntaxTree>();

            // Generate placeholders for DTOs that don't have an explicit mapper
            foreach (var (dtoSymbol, entitySymbol) in dtosWithAttribute)
            {
                var mapperName = $"{dtoSymbol.Name}Mapper";
                if (!explicitMappers.ContainsKey(mapperName))
                {
                    var entityFullName = entitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var dtoFullName = dtoSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var ns = dtoSymbol.ContainingNamespace.IsGlobalNamespace ? "" : $"namespace {dtoSymbol.ContainingNamespace.ToDisplayString()}";

                    var sourceText = $@"// <auto-generated-placeholder/>
{ns}
{{
    public partial class {mapperName} : global::ProjectR.Mapper<{entityFullName}, {dtoFullName}> {{ }}
}}";
                    context.AddSource($"{mapperName}.ph.g.cs", sourceText);
                    var syntaxTree = CSharpSyntaxTree.ParseText(sourceText, path: $"{mapperName}.ph.g.cs");
                    placeholderSyntaxTrees.Add(syntaxTree);

                    var placeholderClassNode = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>().First();
                    allMapperClassesToImplement.Add(placeholderClassNode);
                }
            }

            var compilationWithPlaceholders = compilation.AddSyntaxTrees(placeholderSyntaxTrees);
            var distinctClasses = allMapperClassesToImplement.Distinct().ToList();
            var allMappers = new List<INamedTypeSymbol>();

            foreach (var mapperClass in distinctClasses)
            {
                var semanticModel = compilationWithPlaceholders.GetSemanticModel(mapperClass.SyntaxTree);
                if (semanticModel.GetDeclaredSymbol(mapperClass) is INamedTypeSymbol symbol)
                {
                    allMappers.Add(symbol);
                }
            }

            foreach (var mapperClass in distinctClasses)
            {
                try
                {
                    ProcessMapperClass(compilationWithPlaceholders, mapperClass, context, allMappers);
                }
                catch (Exception ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(Diagnostics.UnexpectedError, mapperClass.GetLocation(), ex.Message, ex.StackTrace));
                }
            }
        }

        private static void CollectUsings(ITypeSymbol typeSymbol, HashSet<string> usings)
        {
            foreach (var syntaxRef in typeSymbol.DeclaringSyntaxReferences)
            {
                var syntaxNode = syntaxRef.GetSyntax();
                if (syntaxNode?.SyntaxTree?.GetRoot() is CompilationUnitSyntax root)
                {
                    foreach (var u in root.Usings)
                    {
                        usings.Add(u.ToString());
                    }
                }
            }
        }

        private static void ProcessMapperClass(Compilation compilation, ClassDeclarationSyntax mapperClass, SourceProductionContext context, IReadOnlyList<INamedTypeSymbol> allMappers)
        {
            var semanticModel = compilation.GetSemanticModel(mapperClass.SyntaxTree);
            var mapperSymbol = semanticModel.GetDeclaredSymbol(mapperClass) as INamedTypeSymbol;
            if (mapperSymbol == null) return;

            var baseType = mapperSymbol.BaseType;
            if (baseType == null || baseType.TypeArguments.Length != 2) return;

            var sourceType = baseType.TypeArguments[0];
            var destinationType = baseType.TypeArguments[1];

            var allUsings = new HashSet<string>();
            CollectUsings(mapperSymbol, allUsings);
            CollectUsings(sourceType, allUsings);
            CollectUsings(destinationType, allUsings);

            var policyMethodSyntax = mapperSymbol.GetMembers("ConfigureMappingPolicies")
                .FirstOrDefault(m => m.IsStatic && !m.IsImplicitlyDeclared)?
                .DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as MethodDeclarationSyntax;

            // Use the provided compilation which includes placeholders
            var engine = new PolicyEngine(compilation, policyMethodSyntax, allMappers);

            var projectAsPlan = engine.CreateProjectAsPlan(sourceType, destinationType);
            var buildPlan = engine.CreateBuildPlan(destinationType, sourceType);
            var applyToPlan = engine.CreateApplyToPlan(destinationType, sourceType);

            projectAsPlan.Diagnostics.ForEach(context.ReportDiagnostic);
            buildPlan.Diagnostics.ForEach(context.ReportDiagnostic);
            applyToPlan.Diagnostics.ForEach(context.ReportDiagnostic);

            if (buildPlan.Creation.Method == CreationMethod.None)
            {
                context.ReportDiagnostic(Diagnostic.Create(Diagnostics.NoValidCreationMethod, mapperClass.Identifier.GetLocation(), buildPlan.DestinationType.Name));
                return;
            }

            var codeBuilder = new CodeBuilder();
            var sourceCode = codeBuilder.BuildSource(mapperSymbol, projectAsPlan, buildPlan, applyToPlan, allUsings);

            context.AddSource($"{mapperSymbol.Name}.g.cs", sourceCode);
        }
    }
}

