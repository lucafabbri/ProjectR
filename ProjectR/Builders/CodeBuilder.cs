using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ProjectR
{
    internal class CodeBuilder
    {
        private readonly StringBuilder _sb = new StringBuilder();
        private int _indentationLevel = 0;

        public string BuildSource(INamedTypeSymbol mapperSymbol, MappingPlan projectAsPlan, MappingPlan buildPlan, MappingPlan applyToPlan, HashSet<string> allUsings)
        {
            var dependencies = GetDependencies(projectAsPlan, buildPlan, applyToPlan);
            BuildHeader(mapperSymbol.ContainingNamespace.ToDisplayString(), allUsings);
            BuildClassSignature(mapperSymbol.Name);
            if (dependencies.Any())
            {
                BuildConstructorAndFields(mapperSymbol.Name, dependencies);
            }
            BuildProjectAsMethod(mapperSymbol, projectAsPlan);
            BuildBuildMethod(mapperSymbol, buildPlan);
            BuildApplyToMethod(mapperSymbol, applyToPlan);
            BuildFooter();
            return _sb.ToString();
        }

        private HashSet<INamedTypeSymbol> GetDependencies(params MappingPlan[] plans)
        {
            var dependencies = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
            foreach (var plan in plans)
            {
                foreach (var instruction in plan.Instructions)
                {
                    if (instruction is NestedPropertyMapping nested) dependencies.Add(nested.Mapper);
                    else if (instruction is CollectionPropertyMapping collection) dependencies.Add(collection.ElementMapper);
                }
                foreach (var paramMapping in plan.Creation.ParametersMap.Values)
                {
                    if (paramMapping.Mapper != null) dependencies.Add(paramMapping.Mapper);
                }
            }
            return dependencies;
        }

        private void BuildHeader(string namespaceName, HashSet<string> allUsings)
        {
            _sb.AppendLine("// <auto-generated/>");
            _sb.AppendLine("using System;");
            _sb.AppendLine("using System.Linq;");

            foreach (var u in allUsings.OrderBy(x => x))
            {
                // Evita di ridichiarare using comuni
                if (u.Contains("System;") || u.Contains("System.Linq;")) continue;
                _sb.AppendLine(u);
            }

            _sb.AppendLine();
            _sb.AppendLine($"namespace {namespaceName}");
            _sb.AppendLine("{");
            _indentationLevel++;
        }

        private void BuildClassSignature(string className)
        {
            Indent(); _sb.AppendLine($"public partial class {className}");
            Indent(); _sb.AppendLine("{");
            _indentationLevel++;
        }

        private void BuildConstructorAndFields(string className, HashSet<INamedTypeSymbol> dependencies)
        {
            foreach (var dep in dependencies)
            {
                Indent(); _sb.AppendLine($"private readonly {dep.ToDisplayString()} _{GetFieldName(dep)};");
            }
            _sb.AppendLine();
            Indent(); _sb.AppendLine($"public {className}()");
            Indent(); _sb.AppendLine("{");
            _indentationLevel++;
            foreach (var dep in dependencies)
            {
                Indent(); _sb.AppendLine($"this._{GetFieldName(dep)} = new {dep.ToDisplayString()}();");
            }
            _indentationLevel--;
            Indent(); _sb.AppendLine("}");
            _sb.AppendLine();
        }

        private void BuildProjectAsMethod(INamedTypeSymbol mapperSymbol, MappingPlan plan)
        {
            var sourceTypeName = plan.SourceType.ToDisplayString();
            var destTypeName = plan.DestinationType.ToDisplayString();
            BuildXmlDoc(mapperSymbol, "ProjectAs");
            Indent(); _sb.AppendLine($"public override {destTypeName} ProjectAs({sourceTypeName} source)");
            Indent(); _sb.AppendLine("{");
            _indentationLevel++;
            GenerateNullCheck("source", destTypeName);
            GenerateCreationBlock("destination", plan.DestinationType, plan, "source");
            _indentationLevel--;
            Indent(); _sb.AppendLine("}");
            _sb.AppendLine();
        }

        private void BuildBuildMethod(INamedTypeSymbol mapperSymbol, MappingPlan plan)
        {
            var sourceTypeName = plan.SourceType.ToDisplayString();
            var destTypeName = plan.DestinationType.ToDisplayString();
            BuildXmlDoc(mapperSymbol, "Build");
            Indent(); _sb.AppendLine($"public override {destTypeName} Build({sourceTypeName} source)");
            Indent(); _sb.AppendLine("{");
            _indentationLevel++;
            GenerateNullCheck("source", destTypeName);
            GenerateCreationBlock("destination", plan.DestinationType, plan, "source", true);
            _indentationLevel--;
            Indent(); _sb.AppendLine("}");
            _sb.AppendLine();
        }

        private void BuildApplyToMethod(INamedTypeSymbol mapperSymbol, MappingPlan plan)
        {
            var sourceTypeName = plan.SourceType.ToDisplayString();
            var destTypeName = plan.DestinationType.ToDisplayString();
            BuildXmlDoc(mapperSymbol, "ApplyTo");
            Indent(); _sb.AppendLine($"public override void ApplyTo({sourceTypeName} source, {destTypeName} destination)");
            Indent(); _sb.AppendLine("{");
            _indentationLevel++;
            Indent(); _sb.AppendLine("if (source is null || destination is null) return;");
            _sb.AppendLine();
            GenerateMappingInstructions("source", "destination", plan, isApplyTo: true);
            _indentationLevel--;
            Indent(); _sb.AppendLine("}");
        }

        private void GenerateCreationBlock(string variableName, ITypeSymbol variableType, MappingPlan plan, string sourceVarName, bool isBuild = false)
        {
            Indent(); 
            if(isBuild) _sb.AppendLine("return BuildRefiner(");
            else _sb.AppendLine("return ProjectAsRefiner(");
            _indentationLevel++;
            Indent();

            switch (plan.Creation.Method)
            {
                case CreationMethod.ConstructorWithParameters:
                    var constructorArgs = GetMethodArguments(plan.Creation.Constructor, plan.Creation, sourceVarName);
                    _sb.AppendLine($"new {variableType.ToDisplayString()}({constructorArgs})");
                    break;
                case CreationMethod.FactoryMethod:
                    var factoryArgs = GetMethodArguments(plan.Creation.FactoryMethod, plan.Creation, sourceVarName);
                    _sb.AppendLine($"{variableType.ToDisplayString()}.{plan.Creation.FactoryMethod.Name}({factoryArgs})");
                    break;
                case CreationMethod.ParameterlessConstructor:
                    _sb.AppendLine($"new {variableType.ToDisplayString()}");
                    Indent(); _sb.AppendLine("{");
                    _indentationLevel++;
                    GenerateMappingInstructions(sourceVarName, null, plan, isApplyTo: false);
                    _indentationLevel--;
                    Indent(); _sb.AppendLine("}");
                    break;
                default:
                    if (isBuild)
                    {
                        _sb.AppendLine($"BuildFactoryFallback({variableName})");
                    }
                    _sb.AppendLine($"new {variableType.ToDisplayString()}()");
                    break;
            }
            _sb.Append($", {sourceVarName});");

        }

        private string GetMethodArguments(IMethodSymbol method, CreationInfo creationInfo, string sourceVarName)
        {
            var args = new List<string>();
            foreach (var param in method.Parameters)
            {
                if (creationInfo.CustomParameterExpressions.TryGetValue(param.Name, out var lambda))
                {
                    var body = lambda.Body.ToString();
                    var lambdaParamName = GetLambdaParameterName(lambda);
                    if (!string.IsNullOrEmpty(lambdaParamName))
                        args.Add(body.Replace(lambdaParamName, sourceVarName));
                }
                else if (creationInfo.ParametersMap.TryGetValue(param, out var mappingInfo))
                {
                    var sourceAccess = $"{sourceVarName}.{mappingInfo.SourceProperty.Name}";
                    if (mappingInfo.Mapper != null)
                        args.Add($"this._{GetFieldName(mappingInfo.Mapper)}.Build({sourceAccess})");
                    else
                        args.Add(sourceAccess);
                }
                else args.Add("default");
            }
            return string.Join(", ", args);
        }

        private void GenerateMappingInstructions(string sourceVar, string? destVar, MappingPlan plan, bool isApplyTo)
        {
            foreach (var instruction in plan.Instructions)
            {
                string assignment = "";
                switch (instruction)
                {
                    case CustomExpressionMapping custom:
                        var body = custom.SourceExpression.Body.ToString();
                        var paramName = GetLambdaParameterName(custom.SourceExpression);
                        assignment = $"{custom.Destination.Name} = {body.Replace(paramName, sourceVar)}";
                        break;
                    case SimplePropertyMapping simple:
                        assignment = $"{simple.Destination.Name} = {sourceVar}.{simple.Source.Name}";
                        break;
                    case MethodCallMapping methodCall:
                        foreach (var src in methodCall.Sources)
                        {
                            if (src.Type.IsValueType)
                            {
                                Indent();
                                _sb.AppendLine($"{destVar}.{methodCall.UpdateMethod.Name}({sourceVar}.{src.Name});");
                            }
                        }
                        continue;
                    case CompositePropertyMapping composite:
                        var sourceProps = string.Join(", ", composite.Sources.Select(s => $"{sourceVar}.{s.Name}"));
                        assignment = $"{composite.Destination.Name} = string.Format(\"{composite.Format}\", {sourceProps})";
                        break;
                    case NestedPropertyMapping nested:
                        var nestedMethod = GetNestedMethodName(nested.Source.Type, nested.Destination.Type, isApplyTo);
                        if (isApplyTo)
                        {
                            Indent();
                            _sb.AppendLine($"this._{GetFieldName(nested.Mapper)}.{nestedMethod}({sourceVar}.{nested.Source.Name}, {destVar}.{nested.Destination.Name});");
                            continue;
                        }
                        assignment = $"{nested.Destination.Name} = this._{GetFieldName(nested.Mapper)}.{nestedMethod}({sourceVar}.{nested.Source.Name})";
                        break;
                    case CollectionPropertyMapping collection:
                        var elementMethod = GetNestedMethodName(GetCollectionElementType(collection.Source.Type), GetCollectionElementType(collection.Destination.Type), isApplyTo);
                        assignment = $"{collection.Destination.Name} = {sourceVar}.{collection.Source.Name}?.Select(x => this._{GetFieldName(collection.ElementMapper)}.{elementMethod}(x)).ToList()";
                        break;
                }
                if (!string.IsNullOrEmpty(assignment))
                {
                    Indent();
                    if (destVar != null) _sb.AppendLine($"{destVar}.{assignment};");
                    else _sb.AppendLine($"{assignment},");
                }
            }
        }

        private string GetLambdaParameterName(LambdaExpressionSyntax lambda)
        {
            if (lambda is SimpleLambdaExpressionSyntax simple) return simple.Parameter.Identifier.Text;
            if (lambda is ParenthesizedLambdaExpressionSyntax p && p.ParameterList.Parameters.Count == 1) return p.ParameterList.Parameters[0].Identifier.Text;
            return "";
        }

        private string GetNestedMethodName(ITypeSymbol? sourceType, ITypeSymbol? destinationType, bool isApplyTo)
        {
            if (sourceType == null || destinationType == null) return "ProjectAs";
            bool sourceIsDto = sourceType.Name.EndsWith("Dto"), destIsDto = destinationType.Name.EndsWith("Dto");
            if (isApplyTo) return "ApplyTo";
            if (!sourceIsDto && destIsDto) return "ProjectAs";
            if (sourceIsDto && !destIsDto) return "Build";
            return "ProjectAs";
        }

        private ITypeSymbol? GetCollectionElementType(ITypeSymbol type)
        {
            if (type is INamedTypeSymbol ntSymbol && ntSymbol.IsGenericType) return ntSymbol.TypeArguments.FirstOrDefault();
            var ienumerable = type.AllInterfaces.FirstOrDefault(i => i.Name == "IEnumerable" && i.IsGenericType);
            return ienumerable?.TypeArguments.FirstOrDefault();
        }

        private void GenerateNullCheck(string sourceVar, string returnType)
        {
            Indent(); _sb.AppendLine($"if ({sourceVar} is null) return default({returnType});");
            _sb.AppendLine();
        }

        private void BuildFooter()
        {
            _indentationLevel--;
            Indent(); _sb.AppendLine("}");
            _indentationLevel--;
            _sb.AppendLine("}");
        }

        private void BuildXmlDoc(INamedTypeSymbol mapperSymbol, string methodName)
        {
            var baseMethod = mapperSymbol.BaseType.GetMembers(methodName).OfType<IMethodSymbol>().FirstOrDefault();
            if (baseMethod?.GetDocumentationCommentXml() is string xml && !string.IsNullOrEmpty(xml))
            {
                var lines = xml.Split(new[] { '\r', '\n' }, System.StringSplitOptions.RemoveEmptyEntries).Select(l => l.Trim());
                foreach (var line in lines)
                {
                    Indent(); _sb.AppendLine($"/// {line}");
                }
            }
        }

        private string GetFieldName(INamedTypeSymbol typeSymbol)
        {
            var name = typeSymbol.Name;
            if (name.StartsWith("I")) name = name.Substring(1);
            return char.ToLower(name[0]) + name.Substring(1);
        }

        private void Indent() => _sb.Append(new string(' ', _indentationLevel * 4));
    }
}

