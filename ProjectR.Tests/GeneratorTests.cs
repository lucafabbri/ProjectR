using System.Threading.Tasks;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Testing;
using Microsoft.CodeAnalysis.Testing;
using Microsoft.CodeAnalysis.Testing.Verifiers;
using Microsoft.Extensions.DependencyInjection;
using Xunit;
using ProjectR;

namespace ProjectR.Tests
{
    public static class CSharpSourceGeneratorVerifier<TSourceGenerator>
        where TSourceGenerator : IIncrementalGenerator, new()
    {
        public class Test : CSharpSourceGeneratorTest<TSourceGenerator, XUnitVerifier>
        {
            public Test()
            {
                ReferenceAssemblies = ReferenceAssemblies.Net.Net80.AddPackages(ImmutableArray.Create(
                    new PackageIdentity("Microsoft.Extensions.DependencyInjection", "8.0.0"),
                    new PackageIdentity("Microsoft.Extensions.DependencyInjection.Abstractions", "8.0.0")));
            }

            protected override CompilationOptions CreateCompilationOptions()
            {
                var options = base.CreateCompilationOptions();
                return options.WithSpecificDiagnosticOptions(
                    options.SpecificDiagnosticOptions.SetItems(CSharpVerifierHelper.NullableWarnings));
            }
        }
    }

    internal static class CSharpVerifierHelper
    {
        /// <summary>
        /// By default, the compiler reports diagnostics for nullable reference types at
        /// <see cref="DiagnosticSeverity.Warning"/>, and the analyzer test framework defaults to only validating
        /// diagnostics at <see cref="DiagnosticSeverity.Error"/>. This map contains all compiler diagnostic IDs
        /// related to nullability wrapped with <see cref="ReportDiagnostic.Error"/>, which is then used to enable all
        /// of these warnings for default validation during analyzer and code fix tests.
        /// </summary>
        internal static ImmutableDictionary<string, ReportDiagnostic> NullableWarnings { get; } = GetNullableWarningsFromCompiler();

        private static ImmutableDictionary<string, ReportDiagnostic> GetNullableWarningsFromCompiler()
        {
            string[] args = { "/warnaserror:nullable" };
            var commandLineArguments = CSharpCommandLineParser.Default.Parse(args, baseDirectory: null, sdkDirectory: null);
            return commandLineArguments.CompilationOptions.SpecificDiagnosticOptions;
        }
    }

    public class GeneratorTests
    {
        [Fact]
        public async Task SimpleMapping_GeneratesCorrectCode()
        {
            var source = @"
using ProjectR;

namespace TestNamespace
{
    public class Source
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

    public class Destination
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

    public partial class TestMapper : Mapper<Source, Destination>
    {
    }
}";

            var expected = @"// <auto-generated/>
using System;
using System.Linq;
using ProjectR;

namespace TestNamespace
{
    public partial class TestMapper
    {
        public override TestNamespace.Destination ProjectGenerated(TestNamespace.Source source)
        {
            if (source is null) return default(TestNamespace.Destination);

            return new TestNamespace.Destination
            {
                Id = source.Id,
                Name = source.Name,
            };

        }

        public override TestNamespace.Source BuildGenerated(TestNamespace.Destination source)
        {
            if (source is null) return default(TestNamespace.Source);

            return new TestNamespace.Source
            {
                Id = source.Id,
                Name = source.Name,
            };

        }

    }
}
";

            var expectedRegistration = @"// <auto-generated/>
#nullable enable

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using ProjectR.Services;

using TestNamespace;

namespace TestProject.Generated;

/// <summary>
/// Generated mapper registration for TestProject.
/// Generated by MapperGenerator.
/// </summary>
public static class GeneratedMapperRegistrations_TestProject
{
    /// <summary>
    /// Registers all generated mappers in the DI container.
    /// </summary>
    public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddGeneratedMappers(
        this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {
        // Register individual mappers from this assembly
        services.TryAddSingleton<global::TestNamespace.TestMapper>();
        services.TryAddSingleton<global::ProjectR.Mapper<global::TestNamespace.Source, global::TestNamespace.Destination>>(sp => sp.GetRequiredService<global::TestNamespace.TestMapper>());

        // Register global services (only once)
        services.TryAddSingleton<global::ProjectR.Services.IMapperResolver, global::ProjectR.Services.MapperResolver>();

        return services;
    }
}
";

            var test = new CSharpSourceGeneratorVerifier<MapperGenerator>.Test
            {
                TestState = 
                {
                    Sources = { source },
                    GeneratedSources = 
                    {
                        (typeof(MapperGenerator), "TestMapper.g.cs", expected),
                        (typeof(MapperGenerator), "MapperRegistration.g.cs", expectedRegistration)
                    },
                    AdditionalReferences = 
                    { 
                        MetadataReference.CreateFromFile(typeof(ProjectR.Mapper<,>).Assembly.Location)
                    }
                },
            };

            await test.RunAsync();
        }
    }
}
